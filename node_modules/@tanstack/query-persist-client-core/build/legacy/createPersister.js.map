{"version":3,"sources":["../../src/createPersister.ts"],"sourcesContent":["import { matchQuery } from '@tanstack/query-core'\nimport type {\n  Query,\n  QueryFilters,\n  QueryFunctionContext,\n  QueryKey,\n  QueryState,\n} from '@tanstack/query-core'\n\nexport interface PersistedQuery {\n  buster: string\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport type MaybePromise<T> = T | Promise<T>\n\nexport interface AsyncStorage<TStorageValue = string> {\n  getItem: (key: string) => MaybePromise<TStorageValue | undefined | null>\n  setItem: (key: string, value: TStorageValue) => MaybePromise<unknown>\n  removeItem: (key: string) => MaybePromise<void>\n}\n\nexport interface StoragePersisterOptions<TStorageValue = string> {\n  /** The storage client used for setting and retrieving items from cache.\n   * For SSR pass in `undefined`.\n   */\n  storage: AsyncStorage<TStorageValue> | undefined | null\n  /**\n   * How to serialize the data to storage.\n   * @default `JSON.stringify`\n   */\n  serialize?: (persistedQuery: PersistedQuery) => MaybePromise<TStorageValue>\n  /**\n   * How to deserialize the data from storage.\n   * @default `JSON.parse`\n   */\n  deserialize?: (cachedString: TStorageValue) => MaybePromise<PersistedQuery>\n  /**\n   * A unique string that can be used to forcefully invalidate existing caches,\n   * if they do not share the same buster string\n   */\n  buster?: string\n  /**\n   * The max-allowed age of the cache in milliseconds.\n   * If a persisted cache is found that is older than this\n   * time, it will be discarded\n   * @default 24 hours\n   */\n  maxAge?: number\n  /**\n   * Prefix to be used for storage key.\n   * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.\n   * @default 'tanstack-query'\n   */\n  prefix?: string\n  /**\n   * Filters to narrow down which Queries should be persisted.\n   */\n  filters?: QueryFilters\n}\n\nexport const PERSISTER_KEY_PREFIX = 'tanstack-query'\n\n/**\n * Warning: experimental feature.\n * This utility function enables fine-grained query persistence.\n * Simple add it as a `persister` parameter to `useQuery` or `defaultOptions` on `queryClient`.\n *\n * ```\n * useQuery({\n     queryKey: ['myKey'],\n     queryFn: fetcher,\n     persister: createPersister({\n       storage: localStorage,\n     }),\n   })\n   ```\n */\nexport function experimental_createPersister<TStorageValue = string>({\n  storage,\n  buster = '',\n  maxAge = 1000 * 60 * 60 * 24,\n  serialize = JSON.stringify as Required<\n    StoragePersisterOptions<TStorageValue>\n  >['serialize'],\n  deserialize = JSON.parse as Required<\n    StoragePersisterOptions<TStorageValue>\n  >['deserialize'],\n  prefix = PERSISTER_KEY_PREFIX,\n  filters,\n}: StoragePersisterOptions<TStorageValue>) {\n  return async function persisterFn<T, TQueryKey extends QueryKey>(\n    queryFn: (context: QueryFunctionContext<TQueryKey>) => T | Promise<T>,\n    context: QueryFunctionContext<TQueryKey>,\n    query: Query,\n  ) {\n    const storageKey = `${prefix}-${query.queryHash}`\n    const matchesFilter = filters ? matchQuery(filters, query) : true\n\n    // Try to restore only if we do not have any data in the cache and we have persister defined\n    if (matchesFilter && query.state.data === undefined && storage != null) {\n      try {\n        const storedData = await storage.getItem(storageKey)\n        if (storedData) {\n          const persistedQuery = await deserialize(storedData)\n\n          if (persistedQuery.state.dataUpdatedAt) {\n            const queryAge = Date.now() - persistedQuery.state.dataUpdatedAt\n            const expired = queryAge > maxAge\n            const busted = persistedQuery.buster !== buster\n            if (expired || busted) {\n              await storage.removeItem(storageKey)\n            } else {\n              // Just after restoring we want to get fresh data from the server if it's stale\n              setTimeout(() => {\n                // Set proper updatedAt, since resolving in the first pass overrides those values\n                query.setState({\n                  dataUpdatedAt: persistedQuery.state.dataUpdatedAt,\n                  errorUpdatedAt: persistedQuery.state.errorUpdatedAt,\n                })\n\n                if (query.isStale()) {\n                  query.fetch()\n                }\n              }, 0)\n              // We must resolve the promise here, as otherwise we will have `loading` state in the app until `queryFn` resolves\n              return Promise.resolve(persistedQuery.state.data as T)\n            }\n          } else {\n            await storage.removeItem(storageKey)\n          }\n        }\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(err)\n          console.warn(\n            'Encountered an error attempting to restore query cache from persisted location.',\n          )\n        }\n        await storage.removeItem(storageKey)\n      }\n    }\n\n    // If we did not restore, or restoration failed - fetch\n    const queryFnResult = await queryFn(context)\n\n    if (matchesFilter && storage != null) {\n      // Persist if we have storage defined, we use timeout to get proper state to be persisted\n      setTimeout(async () => {\n        storage.setItem(\n          storageKey,\n          await serialize({\n            state: query.state,\n            queryKey: query.queryKey,\n            queryHash: query.queryHash,\n            buster: buster,\n          }),\n        )\n      }, 0)\n    }\n\n    return Promise.resolve(queryFnResult)\n  }\n}\n"],"mappings":";AAAA,SAAS,kBAAkB;AA+DpB,IAAM,uBAAuB;AAiB7B,SAAS,6BAAqD;AAAA,EACnE;AAAA,EACA,SAAS;AAAA,EACT,SAAS,MAAO,KAAK,KAAK;AAAA,EAC1B,YAAY,KAAK;AAAA,EAGjB,cAAc,KAAK;AAAA,EAGnB,SAAS;AAAA,EACT;AACF,GAA2C;AACzC,SAAO,eAAe,YACpB,SACA,SACA,OACA;AACA,UAAM,aAAa,GAAG,MAAM,IAAI,MAAM,SAAS;AAC/C,UAAM,gBAAgB,UAAU,WAAW,SAAS,KAAK,IAAI;AAG7D,QAAI,iBAAiB,MAAM,MAAM,SAAS,UAAa,WAAW,MAAM;AACtE,UAAI;AACF,cAAM,aAAa,MAAM,QAAQ,QAAQ,UAAU;AACnD,YAAI,YAAY;AACd,gBAAM,iBAAiB,MAAM,YAAY,UAAU;AAEnD,cAAI,eAAe,MAAM,eAAe;AACtC,kBAAM,WAAW,KAAK,IAAI,IAAI,eAAe,MAAM;AACnD,kBAAM,UAAU,WAAW;AAC3B,kBAAM,SAAS,eAAe,WAAW;AACzC,gBAAI,WAAW,QAAQ;AACrB,oBAAM,QAAQ,WAAW,UAAU;AAAA,YACrC,OAAO;AAEL,yBAAW,MAAM;AAEf,sBAAM,SAAS;AAAA,kBACb,eAAe,eAAe,MAAM;AAAA,kBACpC,gBAAgB,eAAe,MAAM;AAAA,gBACvC,CAAC;AAED,oBAAI,MAAM,QAAQ,GAAG;AACnB,wBAAM,MAAM;AAAA,gBACd;AAAA,cACF,GAAG,CAAC;AAEJ,qBAAO,QAAQ,QAAQ,eAAe,MAAM,IAAS;AAAA,YACvD;AAAA,UACF,OAAO;AACL,kBAAM,QAAQ,WAAW,UAAU;AAAA,UACrC;AAAA,QACF;AAAA,MACF,SAAS,KAAK;AACZ,YAAI,QAAQ,IAAI,aAAa,eAAe;AAC1C,kBAAQ,MAAM,GAAG;AACjB,kBAAQ;AAAA,YACN;AAAA,UACF;AAAA,QACF;AACA,cAAM,QAAQ,WAAW,UAAU;AAAA,MACrC;AAAA,IACF;AAGA,UAAM,gBAAgB,MAAM,QAAQ,OAAO;AAE3C,QAAI,iBAAiB,WAAW,MAAM;AAEpC,iBAAW,YAAY;AACrB,gBAAQ;AAAA,UACN;AAAA,UACA,MAAM,UAAU;AAAA,YACd,OAAO,MAAM;AAAA,YACb,UAAU,MAAM;AAAA,YAChB,WAAW,MAAM;AAAA,YACjB;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF,GAAG,CAAC;AAAA,IACN;AAEA,WAAO,QAAQ,QAAQ,aAAa;AAAA,EACtC;AACF;","names":[]}