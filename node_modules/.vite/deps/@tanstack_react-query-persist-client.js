import {
  IsRestoringProvider,
  QueryClientProvider,
  dehydrate,
  hydrate,
  matchQuery
} from "./chunk-43EJG6CC.js";
import {
  require_jsx_runtime
} from "./chunk-77QT2S2G.js";
import {
  require_react
} from "./chunk-5ZSCTX5O.js";
import {
  __toESM
} from "./chunk-QWN5BXRD.js";

// node_modules/@tanstack/query-persist-client-core/build/modern/persist.js
var cacheEventTypes = ["added", "removed", "updated"];
function isCacheEventType(eventType) {
  return cacheEventTypes.includes(eventType);
}
async function persistQueryClientRestore({
  queryClient,
  persister,
  maxAge = 1e3 * 60 * 60 * 24,
  buster = "",
  hydrateOptions
}) {
  try {
    const persistedClient = await persister.restoreClient();
    if (persistedClient) {
      if (persistedClient.timestamp) {
        const expired = Date.now() - persistedClient.timestamp > maxAge;
        const busted = persistedClient.buster !== buster;
        if (expired || busted) {
          return persister.removeClient();
        } else {
          hydrate(queryClient, persistedClient.clientState, hydrateOptions);
        }
      } else {
        return persister.removeClient();
      }
    }
  } catch (err) {
    if (true) {
      console.error(err);
      console.warn(
        "Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded."
      );
    }
    await persister.removeClient();
    throw err;
  }
}
async function persistQueryClientSave({
  queryClient,
  persister,
  buster = "",
  dehydrateOptions
}) {
  const persistClient = {
    buster,
    timestamp: Date.now(),
    clientState: dehydrate(queryClient, dehydrateOptions)
  };
  await persister.persistClient(persistClient);
}
function persistQueryClientSubscribe(props) {
  const unsubscribeQueryCache = props.queryClient.getQueryCache().subscribe((event) => {
    if (isCacheEventType(event.type)) {
      persistQueryClientSave(props);
    }
  });
  const unsubscribeMutationCache = props.queryClient.getMutationCache().subscribe((event) => {
    if (isCacheEventType(event.type)) {
      persistQueryClientSave(props);
    }
  });
  return () => {
    unsubscribeQueryCache();
    unsubscribeMutationCache();
  };
}
function persistQueryClient(props) {
  let hasUnsubscribed = false;
  let persistQueryClientUnsubscribe;
  const unsubscribe = () => {
    hasUnsubscribed = true;
    persistQueryClientUnsubscribe == null ? void 0 : persistQueryClientUnsubscribe();
  };
  const restorePromise = persistQueryClientRestore(props).then(() => {
    if (!hasUnsubscribed) {
      persistQueryClientUnsubscribe = persistQueryClientSubscribe(props);
    }
  });
  return [unsubscribe, restorePromise];
}

// node_modules/@tanstack/query-persist-client-core/build/modern/retryStrategies.js
var removeOldestQuery = ({ persistedClient }) => {
  const mutations = [...persistedClient.clientState.mutations];
  const queries = [...persistedClient.clientState.queries];
  const client = {
    ...persistedClient,
    clientState: { mutations, queries }
  };
  const sortedQueries = [...queries].sort(
    (a, b) => a.state.dataUpdatedAt - b.state.dataUpdatedAt
  );
  if (sortedQueries.length > 0) {
    const oldestData = sortedQueries.shift();
    client.clientState.queries = queries.filter((q) => q !== oldestData);
    return client;
  }
  return void 0;
};

// node_modules/@tanstack/query-persist-client-core/build/modern/createPersister.js
var PERSISTER_KEY_PREFIX = "tanstack-query";
function experimental_createPersister({
  storage,
  buster = "",
  maxAge = 1e3 * 60 * 60 * 24,
  serialize = JSON.stringify,
  deserialize = JSON.parse,
  prefix = PERSISTER_KEY_PREFIX,
  filters
}) {
  return async function persisterFn(queryFn, context, query) {
    const storageKey = `${prefix}-${query.queryHash}`;
    const matchesFilter = filters ? matchQuery(filters, query) : true;
    if (matchesFilter && query.state.data === void 0 && storage != null) {
      try {
        const storedData = await storage.getItem(storageKey);
        if (storedData) {
          const persistedQuery = await deserialize(storedData);
          if (persistedQuery.state.dataUpdatedAt) {
            const queryAge = Date.now() - persistedQuery.state.dataUpdatedAt;
            const expired = queryAge > maxAge;
            const busted = persistedQuery.buster !== buster;
            if (expired || busted) {
              await storage.removeItem(storageKey);
            } else {
              setTimeout(() => {
                query.setState({
                  dataUpdatedAt: persistedQuery.state.dataUpdatedAt,
                  errorUpdatedAt: persistedQuery.state.errorUpdatedAt
                });
                if (query.isStale()) {
                  query.fetch();
                }
              }, 0);
              return Promise.resolve(persistedQuery.state.data);
            }
          } else {
            await storage.removeItem(storageKey);
          }
        }
      } catch (err) {
        if (true) {
          console.error(err);
          console.warn(
            "Encountered an error attempting to restore query cache from persisted location."
          );
        }
        await storage.removeItem(storageKey);
      }
    }
    const queryFnResult = await queryFn(context);
    if (matchesFilter && storage != null) {
      setTimeout(async () => {
        storage.setItem(
          storageKey,
          await serialize({
            state: query.state,
            queryKey: query.queryKey,
            queryHash: query.queryHash,
            buster
          })
        );
      }, 0);
    }
    return Promise.resolve(queryFnResult);
  };
}

// node_modules/@tanstack/react-query-persist-client/build/modern/PersistQueryClientProvider.js
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var PersistQueryClientProvider = ({
  children,
  persistOptions,
  onSuccess,
  onError,
  ...props
}) => {
  const [isRestoring, setIsRestoring] = React.useState(true);
  const refs = React.useRef({ persistOptions, onSuccess, onError });
  const didRestore = React.useRef(false);
  React.useEffect(() => {
    refs.current = { persistOptions, onSuccess, onError };
  });
  React.useEffect(() => {
    const options = {
      ...refs.current.persistOptions,
      queryClient: props.client
    };
    if (!didRestore.current) {
      didRestore.current = true;
      persistQueryClientRestore(options).then(() => {
        var _a, _b;
        return (_b = (_a = refs.current).onSuccess) == null ? void 0 : _b.call(_a);
      }).catch(() => {
        var _a, _b;
        return (_b = (_a = refs.current).onError) == null ? void 0 : _b.call(_a);
      }).finally(() => {
        setIsRestoring(false);
      });
    }
    return isRestoring ? void 0 : persistQueryClientSubscribe(options);
  }, [props.client, isRestoring]);
  return (0, import_jsx_runtime.jsx)(QueryClientProvider, { ...props, children: (0, import_jsx_runtime.jsx)(IsRestoringProvider, { value: isRestoring, children }) });
};
export {
  PERSISTER_KEY_PREFIX,
  PersistQueryClientProvider,
  experimental_createPersister,
  persistQueryClient,
  persistQueryClientRestore,
  persistQueryClientSave,
  persistQueryClientSubscribe,
  removeOldestQuery
};
//# sourceMappingURL=@tanstack_react-query-persist-client.js.map
