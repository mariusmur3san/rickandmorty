{
  "version": 3,
  "sources": ["../../@tanstack/query-persist-client-core/src/persist.ts", "../../@tanstack/query-persist-client-core/src/retryStrategies.ts", "../../@tanstack/query-persist-client-core/src/createPersister.ts", "../../@tanstack/react-query-persist-client/src/PersistQueryClientProvider.tsx"],
  "sourcesContent": ["import { dehydrate, hydrate } from '@tanstack/query-core'\nimport type {\n  DehydrateOptions,\n  DehydratedState,\n  HydrateOptions,\n  NotifyEventType,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport type Promisable<T> = T | PromiseLike<T>\n\nexport interface Persister {\n  persistClient: (persistClient: PersistedClient) => Promisable<void>\n  restoreClient: () => Promisable<PersistedClient | undefined>\n  removeClient: () => Promisable<void>\n}\n\nexport interface PersistedClient {\n  timestamp: number\n  buster: string\n  clientState: DehydratedState\n}\n\nexport interface PersistQueryClientRootOptions {\n  /** The QueryClient to persist */\n  queryClient: QueryClient\n  /** The Persister interface for storing and restoring the cache\n   * to/from a persisted location */\n  persister: Persister\n  /** A unique string that can be used to forcefully\n   * invalidate existing caches if they do not share the same buster string */\n  buster?: string\n}\n\nexport interface PersistedQueryClientRestoreOptions\n  extends PersistQueryClientRootOptions {\n  /** The max-allowed age of the cache in milliseconds.\n   * If a persisted cache is found that is older than this\n   * time, it will be discarded */\n  maxAge?: number\n  /** The options passed to the hydrate function */\n  hydrateOptions?: HydrateOptions\n}\n\nexport interface PersistedQueryClientSaveOptions\n  extends PersistQueryClientRootOptions {\n  /** The options passed to the dehydrate function */\n  dehydrateOptions?: DehydrateOptions\n}\n\nexport interface PersistQueryClientOptions\n  extends PersistedQueryClientRestoreOptions,\n    PersistedQueryClientSaveOptions,\n    PersistQueryClientRootOptions {}\n\n/**\n * Checks if emitted event is about cache change and not about observers.\n * Useful for persist, where we only want to trigger save when cache is changed.\n */\nconst cacheEventTypes: Array<NotifyEventType> = ['added', 'removed', 'updated']\n\nfunction isCacheEventType(eventType: NotifyEventType) {\n  return cacheEventTypes.includes(eventType)\n}\n\n/**\n * Restores persisted data to the QueryCache\n *  - data obtained from persister.restoreClient\n *  - data is hydrated using hydrateOptions\n * If data is expired, busted, empty, or throws, it runs persister.removeClient\n */\nexport async function persistQueryClientRestore({\n  queryClient,\n  persister,\n  maxAge = 1000 * 60 * 60 * 24,\n  buster = '',\n  hydrateOptions,\n}: PersistedQueryClientRestoreOptions) {\n  try {\n    const persistedClient = await persister.restoreClient()\n\n    if (persistedClient) {\n      if (persistedClient.timestamp) {\n        const expired = Date.now() - persistedClient.timestamp > maxAge\n        const busted = persistedClient.buster !== buster\n        if (expired || busted) {\n          return persister.removeClient()\n        } else {\n          hydrate(queryClient, persistedClient.clientState, hydrateOptions)\n        }\n      } else {\n        return persister.removeClient()\n      }\n    }\n  } catch (err) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(err)\n      console.warn(\n        'Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded.',\n      )\n    }\n\n    await persister.removeClient()\n\n    throw err\n  }\n}\n\n/**\n * Persists data from the QueryCache\n *  - data dehydrated using dehydrateOptions\n *  - data is persisted using persister.persistClient\n */\nexport async function persistQueryClientSave({\n  queryClient,\n  persister,\n  buster = '',\n  dehydrateOptions,\n}: PersistedQueryClientSaveOptions) {\n  const persistClient: PersistedClient = {\n    buster,\n    timestamp: Date.now(),\n    clientState: dehydrate(queryClient, dehydrateOptions),\n  }\n\n  await persister.persistClient(persistClient)\n}\n\n/**\n * Subscribe to QueryCache and MutationCache updates (for persisting)\n * @returns an unsubscribe function (to discontinue monitoring)\n */\nexport function persistQueryClientSubscribe(\n  props: PersistedQueryClientSaveOptions,\n) {\n  const unsubscribeQueryCache = props.queryClient\n    .getQueryCache()\n    .subscribe((event) => {\n      if (isCacheEventType(event.type)) {\n        persistQueryClientSave(props)\n      }\n    })\n\n  const unsubscribeMutationCache = props.queryClient\n    .getMutationCache()\n    .subscribe((event) => {\n      if (isCacheEventType(event.type)) {\n        persistQueryClientSave(props)\n      }\n    })\n\n  return () => {\n    unsubscribeQueryCache()\n    unsubscribeMutationCache()\n  }\n}\n\n/**\n * Restores persisted data to QueryCache and persists further changes.\n */\nexport function persistQueryClient(\n  props: PersistQueryClientOptions,\n): [() => void, Promise<void>] {\n  let hasUnsubscribed = false\n  let persistQueryClientUnsubscribe: (() => void) | undefined\n  const unsubscribe = () => {\n    hasUnsubscribed = true\n    persistQueryClientUnsubscribe?.()\n  }\n\n  // Attempt restore\n  const restorePromise = persistQueryClientRestore(props).then(() => {\n    if (!hasUnsubscribed) {\n      // Subscribe to changes in the query cache to trigger the save\n      persistQueryClientUnsubscribe = persistQueryClientSubscribe(props)\n    }\n  })\n\n  return [unsubscribe, restorePromise]\n}\n", "import type { PersistedClient } from './persist'\n\nexport type PersistRetryer = (props: {\n  persistedClient: PersistedClient\n  error: Error\n  errorCount: number\n}) => PersistedClient | undefined\n\nexport const removeOldestQuery: PersistRetryer = ({ persistedClient }) => {\n  const mutations = [...persistedClient.clientState.mutations]\n  const queries = [...persistedClient.clientState.queries]\n  const client: PersistedClient = {\n    ...persistedClient,\n    clientState: { mutations, queries },\n  }\n\n  // sort queries by dataUpdatedAt (oldest first)\n  const sortedQueries = [...queries].sort(\n    (a, b) => a.state.dataUpdatedAt - b.state.dataUpdatedAt,\n  )\n\n  // clean oldest query\n  if (sortedQueries.length > 0) {\n    const oldestData = sortedQueries.shift()\n    client.clientState.queries = queries.filter((q) => q !== oldestData)\n    return client\n  }\n\n  return undefined\n}\n", "import { matchQuery } from '@tanstack/query-core'\nimport type {\n  Query,\n  QueryFilters,\n  QueryFunctionContext,\n  QueryKey,\n  QueryState,\n} from '@tanstack/query-core'\n\nexport interface PersistedQuery {\n  buster: string\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport type MaybePromise<T> = T | Promise<T>\n\nexport interface AsyncStorage<TStorageValue = string> {\n  getItem: (key: string) => MaybePromise<TStorageValue | undefined | null>\n  setItem: (key: string, value: TStorageValue) => MaybePromise<unknown>\n  removeItem: (key: string) => MaybePromise<void>\n}\n\nexport interface StoragePersisterOptions<TStorageValue = string> {\n  /** The storage client used for setting and retrieving items from cache.\n   * For SSR pass in `undefined`.\n   */\n  storage: AsyncStorage<TStorageValue> | undefined | null\n  /**\n   * How to serialize the data to storage.\n   * @default `JSON.stringify`\n   */\n  serialize?: (persistedQuery: PersistedQuery) => MaybePromise<TStorageValue>\n  /**\n   * How to deserialize the data from storage.\n   * @default `JSON.parse`\n   */\n  deserialize?: (cachedString: TStorageValue) => MaybePromise<PersistedQuery>\n  /**\n   * A unique string that can be used to forcefully invalidate existing caches,\n   * if they do not share the same buster string\n   */\n  buster?: string\n  /**\n   * The max-allowed age of the cache in milliseconds.\n   * If a persisted cache is found that is older than this\n   * time, it will be discarded\n   * @default 24 hours\n   */\n  maxAge?: number\n  /**\n   * Prefix to be used for storage key.\n   * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.\n   * @default 'tanstack-query'\n   */\n  prefix?: string\n  /**\n   * Filters to narrow down which Queries should be persisted.\n   */\n  filters?: QueryFilters\n}\n\nexport const PERSISTER_KEY_PREFIX = 'tanstack-query'\n\n/**\n * Warning: experimental feature.\n * This utility function enables fine-grained query persistence.\n * Simple add it as a `persister` parameter to `useQuery` or `defaultOptions` on `queryClient`.\n *\n * ```\n * useQuery({\n     queryKey: ['myKey'],\n     queryFn: fetcher,\n     persister: createPersister({\n       storage: localStorage,\n     }),\n   })\n   ```\n */\nexport function experimental_createPersister<TStorageValue = string>({\n  storage,\n  buster = '',\n  maxAge = 1000 * 60 * 60 * 24,\n  serialize = JSON.stringify as Required<\n    StoragePersisterOptions<TStorageValue>\n  >['serialize'],\n  deserialize = JSON.parse as Required<\n    StoragePersisterOptions<TStorageValue>\n  >['deserialize'],\n  prefix = PERSISTER_KEY_PREFIX,\n  filters,\n}: StoragePersisterOptions<TStorageValue>) {\n  return async function persisterFn<T, TQueryKey extends QueryKey>(\n    queryFn: (context: QueryFunctionContext<TQueryKey>) => T | Promise<T>,\n    context: QueryFunctionContext<TQueryKey>,\n    query: Query,\n  ) {\n    const storageKey = `${prefix}-${query.queryHash}`\n    const matchesFilter = filters ? matchQuery(filters, query) : true\n\n    // Try to restore only if we do not have any data in the cache and we have persister defined\n    if (matchesFilter && query.state.data === undefined && storage != null) {\n      try {\n        const storedData = await storage.getItem(storageKey)\n        if (storedData) {\n          const persistedQuery = await deserialize(storedData)\n\n          if (persistedQuery.state.dataUpdatedAt) {\n            const queryAge = Date.now() - persistedQuery.state.dataUpdatedAt\n            const expired = queryAge > maxAge\n            const busted = persistedQuery.buster !== buster\n            if (expired || busted) {\n              await storage.removeItem(storageKey)\n            } else {\n              // Just after restoring we want to get fresh data from the server if it's stale\n              setTimeout(() => {\n                // Set proper updatedAt, since resolving in the first pass overrides those values\n                query.setState({\n                  dataUpdatedAt: persistedQuery.state.dataUpdatedAt,\n                  errorUpdatedAt: persistedQuery.state.errorUpdatedAt,\n                })\n\n                if (query.isStale()) {\n                  query.fetch()\n                }\n              }, 0)\n              // We must resolve the promise here, as otherwise we will have `loading` state in the app until `queryFn` resolves\n              return Promise.resolve(persistedQuery.state.data as T)\n            }\n          } else {\n            await storage.removeItem(storageKey)\n          }\n        }\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(err)\n          console.warn(\n            'Encountered an error attempting to restore query cache from persisted location.',\n          )\n        }\n        await storage.removeItem(storageKey)\n      }\n    }\n\n    // If we did not restore, or restoration failed - fetch\n    const queryFnResult = await queryFn(context)\n\n    if (matchesFilter && storage != null) {\n      // Persist if we have storage defined, we use timeout to get proper state to be persisted\n      setTimeout(async () => {\n        storage.setItem(\n          storageKey,\n          await serialize({\n            state: query.state,\n            queryKey: query.queryKey,\n            queryHash: query.queryHash,\n            buster: buster,\n          }),\n        )\n      }, 0)\n    }\n\n    return Promise.resolve(queryFnResult)\n  }\n}\n", "'use client'\nimport * as React from 'react'\n\nimport {\n  persistQueryClientRestore,\n  persistQueryClientSubscribe,\n} from '@tanstack/query-persist-client-core'\nimport { IsRestoringProvider, QueryClientProvider } from '@tanstack/react-query'\nimport type { PersistQueryClientOptions } from '@tanstack/query-persist-client-core'\nimport type { OmitKeyof, QueryClientProviderProps } from '@tanstack/react-query'\n\nexport type PersistQueryClientProviderProps = QueryClientProviderProps & {\n  persistOptions: OmitKeyof<PersistQueryClientOptions, 'queryClient'>\n  onSuccess?: () => Promise<unknown> | unknown\n  onError?: () => Promise<unknown> | unknown\n}\n\nexport const PersistQueryClientProvider = ({\n  children,\n  persistOptions,\n  onSuccess,\n  onError,\n  ...props\n}: PersistQueryClientProviderProps): React.JSX.Element => {\n  const [isRestoring, setIsRestoring] = React.useState(true)\n  const refs = React.useRef({ persistOptions, onSuccess, onError })\n  const didRestore = React.useRef(false)\n\n  React.useEffect(() => {\n    refs.current = { persistOptions, onSuccess, onError }\n  })\n\n  React.useEffect(() => {\n    const options = {\n      ...refs.current.persistOptions,\n      queryClient: props.client,\n    }\n    if (!didRestore.current) {\n      didRestore.current = true\n      persistQueryClientRestore(options)\n        .then(() => refs.current.onSuccess?.())\n        .catch(() => refs.current.onError?.())\n        .finally(() => {\n          setIsRestoring(false)\n        })\n    }\n    return isRestoring ? undefined : persistQueryClientSubscribe(options)\n  }, [props.client, isRestoring])\n\n  return (\n    <QueryClientProvider {...props}>\n      <IsRestoringProvider value={isRestoring}>{children}</IsRestoringProvider>\n    </QueryClientProvider>\n  )\n}\n"],
  "mappings": "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",
  "names": []
}
